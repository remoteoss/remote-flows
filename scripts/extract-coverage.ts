#!/usr/bin/env tsx

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { CoverageData, $TSFixMe } from './types';

interface FileCoverage {
  path: string;
  s: Record<string, number>; // statements
  f: Record<string, number>; // functions
  b: Record<string, number | number[]>; // branches
  statementMap: $TSFixMe;
  fnMap: $TSFixMe;
  branchMap: $TSFixMe;
}

function extractCoverage(
  coverageDir: string,
  outputPath?: string,
): CoverageData {
  // Read the coverage-final.json file generated by vitest/istanbul
  const coveragePath = join(coverageDir, 'coverage-final.json');

  let coverageData: Record<string, FileCoverage>;
  try {
    coverageData = JSON.parse(readFileSync(coveragePath, 'utf-8'));
  } catch (error) {
    console.error(`Error reading coverage from ${coveragePath}:`, error);
    process.exit(1);
  }

  // Calculate total coverage across all files
  let totalStatements = 0;
  let coveredStatements = 0;
  let totalFunctions = 0;
  let coveredFunctions = 0;
  let totalBranches = 0;
  let coveredBranches = 0;
  let totalLines = 0;
  let coveredLines = 0;

  for (const file of Object.values(coverageData)) {
    // Count statements
    const statements = Object.values(file.s);
    totalStatements += statements.length;
    coveredStatements += statements.filter((count) => count > 0).length;

    // Count functions
    const functions = Object.values(file.f);
    totalFunctions += functions.length;
    coveredFunctions += functions.filter((count) => count > 0).length;

    // Count branches
    const branches = Object.values(file.b);
    for (const branch of branches) {
      if (Array.isArray(branch)) {
        totalBranches += branch.length;
        coveredBranches += branch.filter((count) => count > 0).length;
      } else {
        totalBranches += 1;
        if (branch > 0) coveredBranches += 1;
      }
    }

    // Count lines from statementMap
    if (file.statementMap) {
      const lineSet = new Set<number>();
      const coveredLineSet = new Set<number>();

      for (const [key, stmt] of Object.entries(file.statementMap)) {
        const stmtData = stmt as $TSFixMe;
        if (stmtData.start?.line) {
          lineSet.add(stmtData.start.line);
          if (file.s[key] > 0) {
            coveredLineSet.add(stmtData.start.line);
          }
        }
      }

      totalLines += lineSet.size;
      coveredLines += coveredLineSet.size;
    }
  }

  // Calculate percentages
  const statementsPct =
    totalStatements > 0 ? (coveredStatements / totalStatements) * 100 : 0;
  const functionsPct =
    totalFunctions > 0 ? (coveredFunctions / totalFunctions) * 100 : 0;
  const branchesPct =
    totalBranches > 0 ? (coveredBranches / totalBranches) * 100 : 0;
  const linesPct = totalLines > 0 ? (coveredLines / totalLines) * 100 : 0;

  const result: CoverageData = {
    timestamp: new Date().toISOString(),
    lines: {
      total: totalLines,
      covered: coveredLines,
      skipped: 0,
      pct: linesPct,
    },
    statements: {
      total: totalStatements,
      covered: coveredStatements,
      skipped: 0,
      pct: statementsPct,
    },
    functions: {
      total: totalFunctions,
      covered: coveredFunctions,
      skipped: 0,
      pct: functionsPct,
    },
    branches: {
      total: totalBranches,
      covered: coveredBranches,
      skipped: 0,
      pct: branchesPct,
    },
  };

  // Write to output file if specified
  if (outputPath) {
    writeFileSync(outputPath, JSON.stringify(result, null, 2));
    console.log(`Coverage data written to ${outputPath}`);
  } else {
    // Output to stdout
    console.log(JSON.stringify(result, null, 2));
  }

  return result;
}

// Parse command line arguments
const args = process.argv.slice(2);
let coverageDir = 'coverage';
let outputPath: string | undefined;

for (let i = 0; i < args.length; i++) {
  if (args[i] === '--output' || args[i] === '-o') {
    outputPath = args[i + 1];
    i++;
  } else if (args[i] === '--coverage-dir' || args[i] === '-d') {
    coverageDir = args[i + 1];
    i++;
  }
}

try {
  extractCoverage(coverageDir, outputPath);
} catch (error) {
  console.error('Error extracting coverage:', error);
  process.exit(1);
}
